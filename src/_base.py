from abc import ABC, ABCMeta, abstractmethod
from typing import TypeVar, TypedDict

from typing_extensions import Self

from .exceptions import AbstractSingletonInitError, ReinitError


class MetaClassInitDict(TypedDict):
    __module__: str
    __qualname__: str


_AbstractSingletonCls = TypeVar("_AbstractSingletonCls", bound="SingletonMeta")


def _generate_is_abstract_singleton_method(
    __cls: _AbstractSingletonCls,
) -> _AbstractSingletonCls:
    @classmethod
    def _is_abstract_singleton(cls) -> bool:
        return cls is __cls

    __cls._is_abstract_singleton = _is_abstract_singleton  # type: ignore

    return __cls


# Since in Python everything is a class, including classes, they too can be
# initialized in a custom way - this is what metaclasses are supposed to do.
# They are "types of types" - each method within a metaclass is like
# a classmethod in a normal one.
class SingletonMeta(ABCMeta, type):
    def __init__(
        cls, name: str, bases: tuple[type, ...], dct: MetaClassInitDict
    ) -> None:
        del name, bases, dct
        # This will not be overwritten, because the __init__ is for a class,
        # thus called at the moment of class definition.
        cls._instance = None
        # Metaclass' __init__ is called for each child, not only the first that
        # specifies it as its metaclass. This makes auto-generating
        # `_is_abstract_singleton` here impossible.

    # Unfortunately, marking this as abstract does nothing ¯\_(ツ)_/¯
    # but the intent is clearer. It is generated by a decorator
    @abstractmethod
    def _is_abstract_singleton(cls) -> bool:
        ...


@_generate_is_abstract_singleton_method
class SimpleSingleton(ABC, metaclass=SingletonMeta):
    @classmethod
    def instance_exists(cls) -> bool:
        return cls._instance is not None

    def __new__(cls: type[Self], *_, **__) -> Self:
        # The correct error when wrong arguments (or keywords) are given will
        # still be thrown, even if we do not care about them in __new__ method
        del _, __

        if cls._is_abstract_singleton():
            raise AbstractSingletonInitError(cls)

        if cls.instance_exists():
            return cls._instance
        else:
            return cls._create_and_register_new_instance()

    @classmethod
    def _create_and_register_new_instance(cls) -> Self:
        # This has to be done this way, because otherwise WeakRefSingleton
        # will lose the only one hard reference to the instance during
        # it very initialization
        new_instance = cls._create_new_instance()
        cls._instance = new_instance
        return new_instance

    @classmethod
    def _create_new_instance(cls):
        return super().__new__(cls)


@_generate_is_abstract_singleton_method
class NoImplicitReinitSingleton(SimpleSingleton, ABC):
    def __new__(cls: type[Self], *args, **kwds) -> Self:
        if cls.instance_exists():
            raise ReinitError(cls)
        else:
            return super().__new__(cls, *args, **kwds)


@_generate_is_abstract_singleton_method
class ExplicitReinitSingleton(NoImplicitReinitSingleton, ABC):
    @classmethod
    def reinit(cls, *args, **kwds) -> Self:
        cls._unregister_instance()
        new_instance = cls(*args, **kwds)
        return new_instance

    @classmethod
    def _unregister_instance(cls) -> None:
        """
        Override to inject behaviour to `reinit` when the instance is being
        discarted.
        """

        cls._instance = None


@_generate_is_abstract_singleton_method
class WeakRefSingleton(SimpleSingleton, ABC):
    """TODO"""


@_generate_is_abstract_singleton_method
class NoImplicitReinitWeakRefSingleton(
    WeakRefSingleton, NoImplicitReinitSingleton, ABC
):
    """TODO"""

    @classmethod
    def instance_exists(cls) -> Self:
        """TODO"""


@_generate_is_abstract_singleton_method
class ExplicitReinitWeakRefSingleton(
    NoImplicitReinitWeakRefSingleton, ExplicitReinitSingleton, ABC
):
    """TODO"""

    @classmethod
    def reinit(cls, *args, **kwds) -> Self:
        """TODO"""
